What is Playwright?
Quick Overview:

Playwright is a modern browser automation tool by Microsoft
Supports Chromium, Firefox, and WebKit (Safari engine)
Works across Windows, Linux, macOS
Better than Selenium in many ways (we'll see how)

Why Companies Use Playwright:

âœ… Auto-waits for elements (reduces flaky tests)
âœ… Fast execution
âœ… Built-in screenshot, video recording
âœ… Network interception (mock APIs)
âœ… Multiple browser contexts (parallel isolated tests)
âœ… Modern JavaScript app support

-------

Why requirements.txt?
Real scenario: You write automation code on your machine. Your teammate clones the project. How do they install the exact same packages?
Answer: requirements.txt
It's a file that lists all Python packages and their versions.
---

## ğŸ“ Interview Questions You Can Now Answer

**Q: What are the three levels in Playwright architecture?**

**A:** 
1. **Browser** - The top-level browser instance (expensive to create)
2. **Context** - An isolated browsing session, like incognito mode (lightweight, used for parallel testing)
3. **Page** - A single browser tab where we perform automation actions

---

**Q: What is the advantage of Browser Context in Playwright?**

**A:** Browser contexts allow us to create isolated, independent browsing sessions within a single browser instance. This enables:
- Running multiple tests in parallel without interference
- Testing different user scenarios simultaneously (admin vs regular user)
- Better resource utilization (one browser, multiple contexts)
- Avoiding cookie/cache conflicts between tests

---

**Q: Why is Playwright better than Selenium for handling flaky tests?**

**A:** Playwright has built-in auto-waiting mechanisms. It automatically waits for elements to be:
- Attached to DOM
- Visible
- Stable (not animating)
- Enabled
- Ready for interaction

This eliminates most manual wait logic that causes flakiness in Selenium tests.

---
Professional Approach:
LearnNow/
â”‚
â”œâ”€â”€ tests/              # All test files
â”œâ”€â”€ pages/              # Page Object Model classes
â”œâ”€â”€ utils/              # Helper functions (screenshot, date, etc.)
â”œâ”€â”€ test_data/          # Test data (JSON, CSV, Excel)
â”œâ”€â”€ reports/            # Test execution reports
â”œâ”€â”€ screenshots/        # Failure screenshots
â”œâ”€â”€ requirements.txt    # Python dependencies
â”œâ”€â”€ pytest.ini          # Pytest configuration
â”œâ”€â”€ .gitignore         # Files to ignore in Git
â”œâ”€â”€ README.md          # Project documentation
â””â”€â”€ venv/              # Virtual environment (already exists)

----
**Purpose:** Contains Page Object Model (POM) classes

**What is POM?** We'll learn futher, but quick overview:
- Each web page = One Python class
- Contains all locators and actions for that page
- Makes tests clean and reusable

**Example files:**
```
pages/
â”œâ”€â”€ base_page.py        # Common methods (all pages inherit)
â”œâ”€â”€ login_page.py       # Login page locators & methods
â”œâ”€â”€ home_page.py        # Home page locators & methods
â””â”€â”€ forms_page.py       # Forms page locators & methods
```

**Real scenario:**
- Login button selector changes? â†’ Fix in ONE place (login_page.py)
- No need to update 50 test files!