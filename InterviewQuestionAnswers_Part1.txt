What is Playwright?
Quick Overview:

Playwright is a modern browser automation tool by Microsoft
Supports Chromium, Firefox, and WebKit (Safari engine)
Works across Windows, Linux, macOS
Better than Selenium in many ways (we'll see how)

Why Companies Use Playwright:

âœ… Auto-waits for elements (reduces flaky tests)
âœ… Fast execution
âœ… Built-in screenshot, video recording
âœ… Network interception (mock APIs)
âœ… Multiple browser contexts (parallel isolated tests)
âœ… Modern JavaScript app support

-------

Why requirements.txt?
Real scenario: You write automation code on your machine. Your teammate clones the project. How do they install the exact same packages?
Answer: requirements.txt
It's a file that lists all Python packages and their versions.
---

## ğŸ“ Interview Questions You Can Now Answer

**Q: What are the three levels in Playwright architecture?**

**A:** 
1. **Browser** - The top-level browser instance (expensive to create)
2. **Context** - An isolated browsing session, like incognito mode (lightweight, used for parallel testing)
3. **Page** - A single browser tab where we perform automation actions

---

**Q: What is the advantage of Browser Context in Playwright?**

**A:** Browser contexts allow us to create isolated, independent browsing sessions within a single browser instance. This enables:
- Running multiple tests in parallel without interference
- Testing different user scenarios simultaneously (admin vs regular user)
- Better resource utilization (one browser, multiple contexts)
- Avoiding cookie/cache conflicts between tests

---

**Q: Why is Playwright better than Selenium for handling flaky tests?**

**A:** Playwright has built-in auto-waiting mechanisms. It automatically waits for elements to be:
- Attached to DOM
- Visible
- Stable (not animating)
- Enabled
- Ready for interaction

This eliminates most manual wait logic that causes flakiness in Selenium tests.

---
Professional Approach:
LearnNow/
â”‚
â”œâ”€â”€ tests/              # All test files
â”œâ”€â”€ pages/              # Page Object Model classes
â”œâ”€â”€ utils/              # Helper functions (screenshot, date, etc.)
â”œâ”€â”€ test_data/          # Test data (JSON, CSV, Excel)
â”œâ”€â”€ reports/            # Test execution reports
â”œâ”€â”€ screenshots/        # Failure screenshots
â”œâ”€â”€ requirements.txt    # Python dependencies
â”œâ”€â”€ pytest.ini          # Pytest configuration
â”œâ”€â”€ .gitignore         # Files to ignore in Git
â”œâ”€â”€ README.md          # Project documentation
â””â”€â”€ venv/              # Virtual environment (already exists)

----
**Purpose:** Contains Page Object Model (POM) classes

**What is POM?** We'll learn futher, but quick overview:
- Each web page = One Python class
- Contains all locators and actions for that page
- Makes tests clean and reusable

**Example files:**
```
pages/
â”œâ”€â”€ base_page.py        # Common methods (all pages inherit)
â”œâ”€â”€ login_page.py       # Login page locators & methods
â”œâ”€â”€ home_page.py        # Home page locators & methods
â””â”€â”€ forms_page.py       # Forms page locators & methods
```

**Real scenario:**
- Login button selector changes? â†’ Fix in ONE place (login_page.py)
- No need to update 50 test files!

---- 
Why added init files in tests/ ,pages/,utils/
**Why?**
- Allows Python to import modules from these folders
- Example: `from pages.login_page import LoginPage`

--- 
Q: Explain the folder structure you use in your automation framework.
A:
"I use a modular folder structure:

tests/ - Contains all test files following pytest naming convention
pages/ - Page Object Model classes for maintainability
utils/ - Reusable helper functions like random data generators
test_data/ - External test data in JSON/CSV format
reports/ and screenshots/ - Auto-generated artifacts
pytest.ini - Centralized pytest configuration
.gitignore - Excludes unnecessary files from version control

This structure ensures scalability, maintainability, and follows industry standards."

Q: What is the purpose of init.py?
A:
"init.py marks a directory as a Python package, allowing us to import modules from it. For example, with init.py in the pages/ folder, I can do:
pythonfrom pages.login_page import LoginPage
Without it, Python won't recognize the folder as a package and imports will fail."

Q: Why do we use .gitignore?
A:
".gitignore prevents unnecessary or sensitive files from being committed to version control. For example:

Virtual environments (venv/) - large and machine-specific
Generated reports and screenshots - can be recreated
IDE settings (.vscode/) - personal preferences
Python cache (pycache/) - auto-generated

This keeps the repository clean, reduces repo size, and avoids conflicts."

Q: What is pytest.ini used for?
A:
"pytest.ini is a configuration file that defines pytest behavior:

Test discovery patterns (which files to treat as tests)
Markers for categorizing tests (smoke, regression)
Default command-line options (verbose mode, report format)
Test paths to search

This allows consistent test execution across different environments and team members."

-----
What is Auto-Waiting?
Playwright automatically waits for elements before interacting with them.
Checks before clicking a button:

âœ… Element is attached to DOM
âœ… Element is visible
âœ… Element is stable (not animating)
âœ… Element is enabled (not disabled)
âœ… Element is not covered by another element

All of this happens automatically!

Selenium vs Playwright
Selenium (Manual Waiting):
python# You must explicitly wait
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

wait = WebDriverWait(driver, 10)
element = wait.until(EC.element_to_be_clickable((By.ID, "submit")))
element.click()

# 5 lines of code! ğŸ˜«
Playwright (Auto-Waiting):
python# Just click - Playwright handles waiting!
page.click("#submit")

# 1 line of code! ğŸ˜Š

-----